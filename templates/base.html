{% load static %}
{% load i18n %}
<!DOCTYPE html>
<html lang="{{ LANGUAGE_CODE }}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="description" content="ERPlora Hub - Point of Sale System">
    <title>{% block title %}ERPlora Hub{% endblock %}</title>

    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#171F30" media="(prefers-color-scheme: dark)">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="ERPlora Hub">
    <link rel="manifest" href="/manifest.json">

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="{% static 'img/favicon.ico' %}">
    <link rel="apple-touch-icon" href="{% static 'img/icons/icon-152x152.png' %}">

    <!-- @erplora/ux CSS (components + Tailwind utilities) — CDN -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ERPlora/ux@main/dist/ux-full.min.css">

    <!-- ERPlora Hub Custom CSS (fonts + hub styles) -->
    <link rel="stylesheet" href="{% static 'css/main.css' %}">

    <!-- ERPlora Bridge config (from HubConfig) + WebSocket client -->
    <script>
        window.ERPlora = window.ERPlora || {};
        window.ERPlora.bridgeConfig = {
            enabled: {{ HUB_CONFIG.bridge_enabled|yesno:"true,false" }},
            port: {{ HUB_CONFIG.bridge_port }}
        };
    </script>
    <script src="{% static 'js/bridge.js' %}" defer></script>

    <!-- Alpine.js (CDN) -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>

    <!-- Alpine.js Global Stores -->
    <script>
        document.addEventListener('alpine:init', () => {
            // Navigation Store - Tracks current active section/module
            Alpine.store('nav', {
                currentPath: window.location.pathname,

                // Update current path and mark active nav items
                setPath(path) {
                    this.currentPath = path;
                    this.updateActiveItems();
                },

                // Check if a path matches the current active path
                isActive(itemPath) {
                    if (!itemPath || !this.currentPath) return false;
                    // Exact match or starts with (for nested routes)
                    return this.currentPath === itemPath ||
                           this.currentPath.startsWith(itemPath + '/');
                },

                // Update all nav items in sidebar
                updateActiveItems() {
                    const navItems = document.querySelectorAll('.ui-nav-item, .nav-item, .submenu-item');
                    navItems.forEach(item => {
                        const href = item.getAttribute('hx-get') || item.getAttribute('href');
                        if (href) {
                            item.classList.toggle('active', this.isActive(href));
                        }
                    });

                    // Also update accordion groups if any submenu is active
                    document.querySelectorAll('.ui-accordion').forEach(accordion => {
                        const hasActiveChild = accordion.querySelector('.submenu-item.active');
                        accordion.classList.toggle('accordion-has-active', !!hasActiveChild);
                    });
                },

                // Initialize on page load
                init() {
                    // Wait for DOM to be ready
                    setTimeout(() => this.updateActiveItems(), 100);
                }
            });

            // Form Sidebar Store - Controls sliding sidebar for forms
            Alpine.store('sidebar', {
                isOpen: false,
                title: '',
                open(title = '') {
                    this.title = title;
                    this.isOpen = true;
                },
                close() {
                    this.isOpen = false;
                    this.title = '';
                },
                toggle() {
                    this.isOpen = !this.isOpen;
                }
            });

            // Bridge Store - Hardware bridge connection state
            Alpine.store('bridge', {
                connected: false,
                printers: [],
                init() {
                    document.addEventListener('erplora:bridge:connected', () => {
                        this.connected = true;
                        // Request printer list on connect
                        if (window.ERPlora && window.ERPlora.bridge) {
                            window.ERPlora.bridge.discoverPrinters()
                                .then(p => { this.printers = p; })
                                .catch(() => {});
                        }
                    });
                    document.addEventListener('erplora:bridge:disconnected', () => {
                        this.connected = false;
                        this.printers = [];
                    });
                }
            });

            // UI Store - Toast notifications, delete confirmations, etc.
            Alpine.store('ui', {
                // Show toast notification (delegates to global showToast)
                toast(message, type = 'default', duration = 4000) {
                    if (typeof showToast === 'function') {
                        showToast(message, type, duration);
                    }
                },

                // Show success toast
                success(message) {
                    this.toast(message, 'success');
                },

                // Show error toast
                error(message) {
                    this.toast(message, 'error', 5000);
                },

                // Get CSRF token
                getCsrfToken() {
                    const csrfInput = document.querySelector('[name=csrfmiddlewaretoken]');
                    if (csrfInput) return csrfInput.value;
                    const cookies = document.cookie.split(';');
                    for (let cookie of cookies) {
                        const [name, value] = cookie.trim().split('=');
                        if (name === 'csrftoken') return value;
                    }
                    return '';
                },

                // Update table counter after row deletion
                updateTableCounter() {
                    const counterEl = document.querySelector('.infinite-scroll-end');
                    if (!counterEl) return;

                    // Count remaining visible rows in tbody
                    const tbody = document.querySelector('[id$="-tbody"], .data-table tbody');
                    if (!tbody) return;

                    const rowCount = tbody.querySelectorAll('tr').length;

                    // Extract entity name from current text (e.g., "5 products" -> "products")
                    const currentText = counterEl.textContent.trim();
                    const match = currentText.match(/\d+\s+(.+)/);
                    const entityName = match ? match[1] : 'items';

                    // Update counter text - handle singular/plural
                    if (rowCount === 0) {
                        counterEl.remove();
                    } else if (rowCount === 1) {
                        // Remove trailing 's' for singular
                        const singular = entityName.endsWith('s') ? entityName.slice(0, -1) : entityName;
                        counterEl.textContent = `1 ${singular}`;
                    } else {
                        counterEl.textContent = `${rowCount} ${entityName}`;
                    }
                },

                // Confirm delete with UX alert modal
                confirmDelete(deleteUrl, itemName, method, buttonElement) {
                    const self = this;

                    // Create modal backdrop
                    const backdrop = document.createElement('div');
                    backdrop.className = 'modal-backdrop';
                    backdrop.setAttribute('data-state', 'open');

                    backdrop.innerHTML = `
                        <div class="modal modal-sm">
                            <div class="modal-header">
                                <h3 class="modal-title">{% trans "Confirm Delete" %}</h3>
                            </div>
                            <div class="modal-body">
                                <p>{% trans "Are you sure you want to delete" %} "${itemName}"?</p>
                            </div>
                            <div class="modal-footer">
                                <button class="btn btn-outline" data-action="cancel">{% trans "Cancel" %}</button>
                                <button class="btn color-error" data-action="confirm">{% trans "Delete" %}</button>
                            </div>
                        </div>
                    `;

                    document.body.appendChild(backdrop);

                    backdrop.querySelector('[data-action="cancel"]').addEventListener('click', () => {
                        backdrop.setAttribute('data-state', 'closed');
                        setTimeout(() => backdrop.remove(), 300);
                    });

                    backdrop.querySelector('[data-action="confirm"]').addEventListener('click', async () => {
                        backdrop.setAttribute('data-state', 'closed');
                        setTimeout(() => backdrop.remove(), 300);

                        const row = buttonElement.closest('tr');
                        const actionsDiv = buttonElement.closest('[x-data]');

                        if (actionsDiv && actionsDiv._x_dataStack) {
                            actionsDiv._x_dataStack[0].deleting = true;
                        }

                        try {
                            const response = await fetch(deleteUrl, {
                                method: method || 'POST',
                                headers: {
                                    'X-CSRFToken': self.getCsrfToken(),
                                    'Content-Type': 'application/json',
                                }
                            });

                            const data = await response.json();

                            if (data.success) {
                                if (row) {
                                    row.style.transition = 'opacity 0.5s';
                                    row.style.opacity = '0';
                                    setTimeout(() => {
                                        row.remove();
                                        self.updateTableCounter();
                                    }, 500);
                                }
                                self.success(data.message || '{% trans "Deleted successfully" %}');
                            } else {
                                self.error(data.message || '{% trans "Error deleting" %}');
                            }
                        } catch (error) {
                            console.error('Delete error:', error);
                            self.error('{% trans "Error deleting" %}');
                        } finally {
                            if (actionsDiv && actionsDiv._x_dataStack) {
                                actionsDiv._x_dataStack[0].deleting = false;
                            }
                        }
                    });
                }
            });
        });
    </script>

    <!-- HTMX (CDN) -->
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>

    <!-- HTMX Configuration -->
    <script>
        // Enable HTMX to process inline scripts
        htmx.config.allowScriptTags = true;

        document.addEventListener('DOMContentLoaded', function() {
            // Include CSRF token and module ID in all HTMX requests
            document.body.addEventListener('htmx:configRequest', function(event) {
                event.detail.headers['X-CSRFToken'] = '{{ csrf_token }}';

                // Include current module ID for navigation context detection
                // This allows the server to know if we're navigating within the same module
                var currentModule = document.body.getAttribute('data-module-id');
                if (currentModule) {
                    event.detail.headers['X-Module-Id'] = currentModule;
                }
            });

            // Re-initialize Alpine components after HTMX settles
            // Using 'afterSettle' instead of 'afterSwap' to ensure scripts have executed
            document.body.addEventListener('htmx:afterSettle', function(event) {
                // Let Alpine process any new x-data elements
                if (typeof Alpine !== 'undefined') {
                    Alpine.initTree(event.detail.target);
                }
            });

            // Update sidebar active state when URL changes via HTMX
            document.body.addEventListener('htmx:pushedIntoHistory', function(event) {
                if (typeof Alpine !== 'undefined' && Alpine.store('nav')) {
                    Alpine.store('nav').setPath(event.detail.path);
                }
                // Update tabbar selected state
                updateTabbarSelection(event.detail.path);
            });

            // Function to update tabbar selection based on current path
            function updateTabbarSelection(currentPath) {
                var footer = document.getElementById('global-tabbar-footer');
                if (!footer) return;

                footer.querySelectorAll('.tabbar-item').forEach(function(btn) {
                    var btnPath = btn.getAttribute('hx-get');
                    btn.classList.remove('tab-selected');
                    if (btnPath) {
                        // Normalize paths for comparison
                        var normalizedCurrent = currentPath.replace(/\/$/, '');
                        var normalizedBtn = btnPath.replace(/\/$/, '');
                        if (normalizedCurrent === normalizedBtn) {
                            btn.classList.add('tab-selected');
                        }
                    }
                });
            }

            // Also handle back/forward navigation
            window.addEventListener('popstate', function() {
                if (typeof Alpine !== 'undefined' && Alpine.store('nav')) {
                    Alpine.store('nav').setPath(window.location.pathname);
                }
                // Update tabbar selection on back/forward
                updateTabbarSelection(window.location.pathname);
            });

            // Initialize nav store on page load
            setTimeout(function() {
                if (typeof Alpine !== 'undefined' && Alpine.store('nav')) {
                    Alpine.store('nav').init();
                }
            }, 200);

        });
    </script>

    <!-- Automatic Language Detection -->
    <script>
        (function() {
            // Check if user already has a language preference (cookie or session flag)
            function getCookie(name) {
                const value = `; ${document.cookie}`;
                const parts = value.split(`; ${name}=`);
                if (parts.length === 2) return parts.pop().split(';').shift();
                return null;
            }

            const hasPreference = getCookie('django_language');
            const autoLangSet = sessionStorage.getItem('erplora_lang_auto_set');

            // Skip if already has preference OR we've already tried to set it this session
            if (hasPreference || autoLangSet) {
                return;
            }

            // Detect browser language
            const browserLang = navigator.language || navigator.userLanguage;
            const langCode = browserLang.toLowerCase().split('-')[0]; // Get 'es' from 'es-ES'

            // Supported languages
            const supportedLangs = ['en', 'es'];
            const selectedLang = supportedLangs.includes(langCode) ? langCode : 'en';

            // Mark that we've attempted auto-detection (prevent infinite loops)
            sessionStorage.setItem('erplora_lang_auto_set', 'true');

            // Set language preference automatically (only if not English, which is default)
            if (selectedLang !== 'en') {
                // Navigate directly instead of fetch + reload (avoids redirect issues)
                window.location.href = '/set-language/?language=' + selectedLang + '&next=' + encodeURIComponent(window.location.pathname);
            }
        })();
    </script>

    {% block extra_css %}{% endblock %}
    {% block extra_head %}{% endblock %}

    <!-- PWA Install Handler -->
    <script>
        // Store the install prompt event
        let deferredPrompt = null;
        let pwaInstalled = false;

        // Check if app is already installed
        if (window.matchMedia('(display-mode: standalone)').matches) {
            pwaInstalled = true;
        }

        // Listen for the beforeinstallprompt event
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent the mini-infobar from appearing
            e.preventDefault();
            // Save the event for later
            deferredPrompt = e;
            // Show install button
            document.dispatchEvent(new CustomEvent('pwa-installable'));
            console.log('[PWA] Install prompt available');
        });

        // Listen for successful installation
        window.addEventListener('appinstalled', () => {
            pwaInstalled = true;
            deferredPrompt = null;
            document.dispatchEvent(new CustomEvent('pwa-installed'));
            console.log('[PWA] App installed successfully');
        });

        // Function to trigger installation
        async function installPWA() {
            if (!deferredPrompt) {
                console.log('[PWA] No install prompt available');
                return false;
            }

            // Show the install prompt
            deferredPrompt.prompt();

            // Wait for user response
            const { outcome } = await deferredPrompt.userChoice;
            console.log('[PWA] User response:', outcome);

            // Clear the prompt
            deferredPrompt = null;

            return outcome === 'accepted';
        }

        // Check if PWA can be installed
        function canInstallPWA() {
            return deferredPrompt !== null && !pwaInstalled;
        }

        // Check if PWA is installed
        function isPWAInstalled() {
            return pwaInstalled || window.matchMedia('(display-mode: standalone)').matches;
        }
    </script>
    <!-- Auto dark mode detection (runs before body renders to prevent flash) -->
    <script>
        (function() {
            const darkModeAuto = {{ HUB_CONFIG.dark_mode_auto|yesno:"true,false" }};
            const darkModeManual = {{ HUB_CONFIG.dark_mode|yesno:"true,false" }};
            const storedTheme = localStorage.getItem('erplora-theme');

            let isDark = false;
            if (storedTheme) {
                // User has manually toggled — respect their choice
                isDark = storedTheme === 'dark';
            } else if (darkModeAuto) {
                // Use browser/OS preference
                isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            } else {
                // Use manual setting from database
                isDark = darkModeManual;
            }

            // Store for Alpine.js components to access
            window.ERPlora = window.ERPlora || {};
            window.ERPlora.isDark = isDark;
            window.ERPlora.darkModeAuto = darkModeAuto && !storedTheme;

            // Apply data-theme attribute immediately to prevent flash
            if (isDark) {
                document.documentElement.setAttribute('data-theme', 'dark');
            } else {
                document.documentElement.removeAttribute('data-theme');
            }
        })();
    </script>
</head>
<body class="app">
    <script>
        // Listen for system preference changes (only if auto mode and no manual override)
        if (window.ERPlora && window.ERPlora.darkModeAuto) {
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                // Skip if user has set a manual preference since page load
                if (localStorage.getItem('erplora-theme')) return;
                if (e.matches) {
                    document.documentElement.setAttribute('data-theme', 'dark');
                } else {
                    document.documentElement.removeAttribute('data-theme');
                }
                window.ERPlora.isDark = e.matches;
            });
        }
    </script>

    {% block content %}{% endblock %}

    <!-- Toast container -->
    <div id="toast-container" class="toast toast-bottom toast-center"></div>

    <!-- Toast function & HTMX event listeners (must be after #toast-container) -->
    <script>
        (function() {
            var icons = {
                info: '<svg class="toast-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="m11.25 11.25.041-.02a.75.75 0 0 1 1.063.852l-.708 2.836a.75.75 0 0 0 1.063.853l.041-.021M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9-3.75h.008v.008H12V8.25Z"/></svg>',
                success: '<svg class="toast-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75 11.25 15 15 9.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"/></svg>',
                warning: '<svg class="toast-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"/></svg>',
                error: '<svg class="toast-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"/></svg>'
            };
            var closeBtn = '<button class="toast-close" onclick="dismissToast(this)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12"/></svg></button>';

            window.dismissToast = function(btnOrItem) {
                var item = btnOrItem.closest ? (btnOrItem.closest('.toast-item') || btnOrItem) : btnOrItem;
                item.classList.add('toast-removing');
                item.addEventListener('animationend', function() { item.remove(); });
            };

            window.showToast = function(message, type, duration) {
                type = type || 'default';
                duration = duration || 4000;
                var container = document.getElementById('toast-container');
                if (!container) return;
                var colorClass = (type === 'default' || type === 'primary') ? '' : ' color-' + type;
                var icon = icons[type] || '';
                var el = document.createElement('div');
                el.className = 'toast-item' + colorClass;
                el.innerHTML = icon + '<span>' + message + '</span>' + closeBtn;
                container.appendChild(el);
                setTimeout(function() { dismissToast(el.querySelector('.toast-close')); }, duration);
            };
        })();

        // Toast shortcuts & Dialog helpers (used by marketplace scripts)
        window.Toast = {
            success: function(msg, dur) { showToast(msg, 'success', dur); },
            error: function(msg, dur) { showToast(msg, 'error', dur || 5000); },
            warning: function(msg, dur) { showToast(msg, 'warning', dur); },
            info: function(msg, dur) { showToast(msg, 'primary', dur); }
        };
        window.showConfirm = function(header, message, onConfirm, confirmLabel, cancelLabel) {
            var backdrop = document.createElement('div');
            backdrop.className = 'modal-backdrop';
            backdrop.setAttribute('data-state', 'open');
            backdrop.innerHTML =
                '<div class="modal modal-sm">' +
                    '<div class="modal-header">' +
                        '<h3 class="modal-title">' + header + '</h3>' +
                    '</div>' +
                    '<div class="modal-body"><p>' + message + '</p></div>' +
                    '<div class="modal-footer">' +
                        '<button class="btn btn-outline" data-action="cancel">' + (cancelLabel || '{% trans "Cancel" %}') + '</button>' +
                        '<button class="btn color-primary" data-action="confirm">' + (confirmLabel || '{% trans "Confirm" %}') + '</button>' +
                    '</div>' +
                '</div>';
            document.body.appendChild(backdrop);
            function close() {
                backdrop.setAttribute('data-state', 'closed');
                setTimeout(function() { backdrop.remove(); }, 300);
            }
            backdrop.querySelector('[data-action="cancel"]').addEventListener('click', close);
            backdrop.querySelector('[data-action="confirm"]').addEventListener('click', function() {
                close();
                if (onConfirm) onConfirm();
            });
            backdrop.addEventListener('click', function(e) {
                if (e.target === backdrop) close();
            });
        };

        // Debug: log ALL HTMX requests and responses
        document.body.addEventListener('htmx:beforeRequest', function(e) {
            console.log('[Toast] HTMX request starting:', e.detail.elt.tagName, e.detail.path);
        });
        document.body.addEventListener('htmx:beforeOnLoad', function(e) {
            var xhr = e.detail.xhr;
            var trigger = xhr.getResponseHeader('HX-Trigger');
            console.log('[Toast] HTMX response received, status:', xhr.status, 'HX-Trigger:', trigger);
        });
        document.body.addEventListener('htmx:afterRequest', function(e) {
            console.log('[Toast] HTMX afterRequest, successful:', e.detail.successful);
        });

        // HX-Trigger: {"showMessage": {"message": "...", "type": "success"}}
        document.body.addEventListener('showMessage', function(e) {
            console.log('[Toast] showMessage event fired', e.detail);
            var d = e.detail || {};
            var msg = d.message || d.value || '';
            if (msg) showToast(msg, d.type || 'success', d.type === 'error' ? 5000 : 4000);
        });

        // HX-Trigger: {"showNotification": {"title": "...", "message": "...", "type": "..."}}
        document.body.addEventListener('showNotification', function(e) {
            var d = e.detail || {};
            var text = d.title ? (d.title + ': ' + (d.message || '')) : (d.message || '');
            if (text) showToast(text, d.type || 'default');
        });
    </script>

    {% block scripts %}{% endblock %}
</body>
</html>
