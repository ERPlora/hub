{% load static %}
{% load i18n %}
<!DOCTYPE html>
<html lang="{{ LANGUAGE_CODE }}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="description" content="ERPlora Hub - Point of Sale System">
    <title>{% block title %}ERPlora Hub{% endblock %}</title>

    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#3880ff">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="ERPlora Hub">
    <link rel="manifest" href="/manifest.json">

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="{% static 'img/favicon.ico' %}">
    <link rel="apple-touch-icon" href="{% static 'img/icons/icon-152x152.png' %}">

    <!-- Plus Jakarta Sans Font (local) -->
    <link rel="stylesheet" href="{% static 'fonts/plus-jakarta-sans/plus-jakarta-sans.css' %}">

    <!-- Ionic CSS (offline) -->
    <link rel="stylesheet" href="{% static 'css/ionic.bundle.css' %}" />

    <!-- Theme Colors (from HubConfig) -->
    <link rel="stylesheet" href="{% static 'css/themes/' %}{{ HUB_CONFIG.color_theme|default:'default' }}/ionic-theme.css" id="theme-stylesheet">

    <!-- ERPlora Base CSS -->
    <link rel="stylesheet" href="{% static 'css/main.css' %}">

    <!-- UI Components CSS -->
    <link rel="stylesheet" href="{% static 'ui/ui.css' %}">

    <!-- Alpine.js (offline) -->
    <script defer src="{% static 'js/alpine.min.js' %}"></script>

    <!-- Alpine.js Global Stores -->
    <script>
        document.addEventListener('alpine:init', () => {
            // Navigation Store - Tracks current active section/module
            Alpine.store('nav', {
                currentPath: window.location.pathname,

                // Update current path and mark active nav items
                setPath(path) {
                    this.currentPath = path;
                    this.updateActiveItems();
                },

                // Check if a path matches the current active path
                isActive(itemPath) {
                    if (!itemPath || !this.currentPath) return false;
                    // Exact match or starts with (for nested routes)
                    return this.currentPath === itemPath ||
                           this.currentPath.startsWith(itemPath + '/');
                },

                // Update all nav items in sidebar
                updateActiveItems() {
                    const navItems = document.querySelectorAll('.ui-nav-item, .nav-item, .submenu-item');
                    navItems.forEach(item => {
                        const href = item.getAttribute('hx-get') || item.getAttribute('href');
                        if (href) {
                            item.classList.toggle('active', this.isActive(href));
                        }
                    });

                    // Also update accordion groups if any submenu is active
                    document.querySelectorAll('.ui-accordion').forEach(accordion => {
                        const hasActiveChild = accordion.querySelector('.submenu-item.active');
                        accordion.classList.toggle('accordion-has-active', !!hasActiveChild);
                    });
                },

                // Initialize on page load
                init() {
                    // Wait for DOM to be ready
                    setTimeout(() => this.updateActiveItems(), 100);
                }
            });

            // Form Sidebar Store - Controls sliding sidebar for forms
            Alpine.store('sidebar', {
                isOpen: false,
                title: '',
                open(title = '') {
                    this.title = title;
                    this.isOpen = true;
                },
                close() {
                    this.isOpen = false;
                    this.title = '';
                },
                toggle() {
                    this.isOpen = !this.isOpen;
                }
            });

            // Module Grid Component - Used on the home page
            // Displays installed modules with favorites, recent, and search functionality
            Alpine.data('moduleGrid', () => ({
                modules: [],
                favorites: [],
                recent: [],
                searchQuery: '',

                init() {
                    // Load modules data from the JSON script tag
                    const dataEl = document.getElementById('modules-data');
                    if (dataEl) {
                        try {
                            this.modules = JSON.parse(dataEl.textContent) || [];
                        } catch (e) {
                            console.error('Error parsing modules data:', e);
                            this.modules = [];
                        }
                    }
                    // Load favorites and recent from localStorage
                    this.favorites = JSON.parse(localStorage.getItem('erplora_favorite_modules') || '[]');
                    this.recent = JSON.parse(localStorage.getItem('erplora_recent_modules') || '[]');
                },

                get filteredModules() {
                    if (!this.searchQuery) {
                        return this.modules;
                    }
                    const query = this.searchQuery.toLowerCase();
                    return this.modules.filter(mod =>
                        mod.label.toLowerCase().includes(query)
                    );
                },

                get favoritesData() {
                    return this.modules.filter(mod => this.favorites.includes(mod.id));
                },

                get recentData() {
                    // Get last 4 recent modules that exist and are not in favorites
                    return this.recent
                        .filter(id => !this.favorites.includes(id))
                        .map(id => this.modules.find(mod => mod.id === id))
                        .filter(mod => mod !== undefined)
                        .slice(0, 4);
                },

                filterModules(event) {
                    this.searchQuery = event.target.value || '';
                },

                isFavorite(moduleId) {
                    return this.favorites.includes(moduleId);
                },

                toggleFavorite(moduleId) {
                    const index = this.favorites.indexOf(moduleId);
                    if (index === -1) {
                        this.favorites.push(moduleId);
                    } else {
                        this.favorites.splice(index, 1);
                    }
                    localStorage.setItem('erplora_favorite_modules', JSON.stringify(this.favorites));
                },

                trackRecent(moduleId) {
                    // Remove if already in recent
                    const index = this.recent.indexOf(moduleId);
                    if (index !== -1) {
                        this.recent.splice(index, 1);
                    }
                    // Add to beginning
                    this.recent.unshift(moduleId);
                    // Keep only last 8
                    this.recent = this.recent.slice(0, 8);
                    localStorage.setItem('erplora_recent_modules', JSON.stringify(this.recent));
                }
            }));

            // UI Store - Toast notifications, delete confirmations, etc.
            Alpine.store('ui', {
                // Show toast notification
                async toast(message, color = 'primary', duration = 2000) {
                    const toast = document.createElement('ion-toast');
                    toast.message = message;
                    toast.duration = duration;
                    toast.color = color;
                    toast.position = 'top';
                    document.body.appendChild(toast);
                    await toast.present();
                },

                // Show success toast
                success(message) {
                    this.toast(message, 'success');
                },

                // Show error toast
                error(message) {
                    this.toast(message, 'danger', 3000);
                },

                // Get CSRF token
                getCsrfToken() {
                    const csrfInput = document.querySelector('[name=csrfmiddlewaretoken]');
                    if (csrfInput) return csrfInput.value;
                    const cookies = document.cookie.split(';');
                    for (let cookie of cookies) {
                        const [name, value] = cookie.trim().split('=');
                        if (name === 'csrftoken') return value;
                    }
                    return '';
                },

                // Update table counter after row deletion
                updateTableCounter() {
                    const counterEl = document.querySelector('.infinite-scroll-end');
                    if (!counterEl) return;

                    // Count remaining visible rows in tbody
                    const tbody = document.querySelector('[id$="-tbody"], .data-table tbody');
                    if (!tbody) return;

                    const rowCount = tbody.querySelectorAll('tr').length;

                    // Extract entity name from current text (e.g., "5 products" -> "products")
                    const currentText = counterEl.textContent.trim();
                    const match = currentText.match(/\d+\s+(.+)/);
                    const entityName = match ? match[1] : 'items';

                    // Update counter text - handle singular/plural
                    if (rowCount === 0) {
                        counterEl.remove();
                    } else if (rowCount === 1) {
                        // Remove trailing 's' for singular
                        const singular = entityName.endsWith('s') ? entityName.slice(0, -1) : entityName;
                        counterEl.textContent = `1 ${singular}`;
                    } else {
                        counterEl.textContent = `${rowCount} ${entityName}`;
                    }
                },

                // Confirm delete with Ionic alert
                async confirmDelete(deleteUrl, itemName, method, buttonElement) {
                    const self = this;
                    const alert = document.createElement('ion-alert');
                    alert.header = '{% trans "Confirm Delete" %}';
                    alert.message = '{% trans "Are you sure you want to delete" %}' + ` "${itemName}"?`;
                    alert.buttons = [
                        {
                            text: '{% trans "Cancel" %}',
                            role: 'cancel',
                            cssClass: 'secondary'
                        },
                        {
                            text: '{% trans "Delete" %}',
                            role: 'confirm',
                            cssClass: 'danger',
                            handler: async () => {
                                const row = buttonElement.closest('tr');
                                const actionsDiv = buttonElement.closest('[x-data]');

                                // Set deleting state if Alpine x-data exists
                                if (actionsDiv && actionsDiv._x_dataStack) {
                                    actionsDiv._x_dataStack[0].deleting = true;
                                }

                                try {
                                    const response = await fetch(deleteUrl, {
                                        method: method || 'POST',
                                        headers: {
                                            'X-CSRFToken': self.getCsrfToken(),
                                            'Content-Type': 'application/json',
                                        }
                                    });

                                    const data = await response.json();

                                    if (data.success) {
                                        // Animate row removal
                                        if (row) {
                                            row.style.transition = 'opacity 0.5s';
                                            row.style.opacity = '0';
                                            setTimeout(() => {
                                                row.remove();
                                                // Update table counter after row removal
                                                self.updateTableCounter();
                                            }, 500);
                                        }
                                        self.success(data.message || '{% trans "Deleted successfully" %}');
                                    } else {
                                        self.error(data.message || '{% trans "Error deleting" %}');
                                    }
                                } catch (error) {
                                    console.error('Delete error:', error);
                                    self.error('{% trans "Error deleting" %}');
                                } finally {
                                    if (actionsDiv && actionsDiv._x_dataStack) {
                                        actionsDiv._x_dataStack[0].deleting = false;
                                    }
                                }
                            }
                        }
                    ];

                    document.body.appendChild(alert);
                    await alert.present();
                }
            });
        });
    </script>

    <!-- HTMX (offline) -->
    <script src="{% static 'js/htmx.min.js' %}"></script>

    <!-- UI Helpers (Toast, Alert, Loading) -->
    <script src="{% static 'js/ui-helpers.js' %}"></script>

    <!-- Ionic Core (offline) -->
    <script type="module" src="{% static 'js/ionic/ionic.esm.js' %}"></script>

    <!-- Swiper Element (Web Components - offline) -->
    <script src="{% static 'js/swiper-element-bundle.min.js' %}"></script>

    <!-- Ionicons (offline) -->
    <script type="module" src="{% static 'ionicons/dist/esm/ionicons.js' %}"></script>
    <script nomodule src="{% static 'ionicons/dist/ionicons.js' %}"></script>

    <!-- Ionic Config (iOS mode) -->
    <script>
        window.Ionic = { config: { mode: 'ios' } };
    </script>

    <!-- Theme Switcher -->
    <script>
        function setTheme(themeName) {
            const themeLink = document.getElementById('theme-stylesheet');
            if (themeLink) {
                themeLink.href = `/static/css/themes/${themeName}/ionic-theme.css`;
            }
        }

        function getCurrentTheme() {
            return '{{ HUB_CONFIG.color_theme|default:"default" }}';
        }
    </script>

    <!-- HTMX Configuration -->
    <script>
        // Enable HTMX to process inline scripts
        htmx.config.allowScriptTags = true;

        document.addEventListener('DOMContentLoaded', function() {
            // Include CSRF token and module ID in all HTMX requests
            document.body.addEventListener('htmx:configRequest', function(event) {
                event.detail.headers['X-CSRFToken'] = '{{ csrf_token }}';

                // Include current module ID for navigation context detection
                // This allows the server to know if we're navigating within the same module
                var currentModule = document.body.getAttribute('data-module-id');
                if (currentModule) {
                    event.detail.headers['X-Module-Id'] = currentModule;
                }
            });

            // Re-initialize Alpine components after HTMX settles
            // Using 'afterSettle' instead of 'afterSwap' to ensure scripts have executed
            document.body.addEventListener('htmx:afterSettle', function(event) {
                // Let Alpine process any new x-data elements
                if (typeof Alpine !== 'undefined') {
                    Alpine.initTree(event.detail.target);
                }
            });

            // Update sidebar active state when URL changes via HTMX
            document.body.addEventListener('htmx:pushedIntoHistory', function(event) {
                if (typeof Alpine !== 'undefined' && Alpine.store('nav')) {
                    Alpine.store('nav').setPath(event.detail.path);
                }
                // Update tabbar selected state
                updateTabbarSelection(event.detail.path);
            });

            // Function to update tabbar selection based on current path
            function updateTabbarSelection(currentPath) {
                var footer = document.getElementById('global-tabbar-footer');
                if (!footer) return;

                footer.querySelectorAll('ion-tab-button').forEach(function(btn) {
                    var btnPath = btn.getAttribute('hx-get');
                    btn.classList.remove('tab-selected');
                    if (btnPath) {
                        // Normalize paths for comparison
                        var normalizedCurrent = currentPath.replace(/\/$/, '');
                        var normalizedBtn = btnPath.replace(/\/$/, '');
                        if (normalizedCurrent === normalizedBtn) {
                            btn.classList.add('tab-selected');
                        }
                    }
                });
            }

            // Also handle back/forward navigation
            window.addEventListener('popstate', function() {
                if (typeof Alpine !== 'undefined' && Alpine.store('nav')) {
                    Alpine.store('nav').setPath(window.location.pathname);
                }
                // Update tabbar selection on back/forward
                updateTabbarSelection(window.location.pathname);
            });

            // Initialize nav store on page load
            setTimeout(function() {
                if (typeof Alpine !== 'undefined' && Alpine.store('nav')) {
                    Alpine.store('nav').init();
                }
            }, 200);

            // Listen for showNotification events from HTMX HX-Trigger headers
            // Usage in Python: response['HX-Trigger'] = json.dumps({'showNotification': {'title': 'Success', 'message': 'Saved!', 'type': 'success'}})
            document.body.addEventListener('showNotification', function(event) {
                const { title, message, type } = event.detail || {};
                if (typeof Notify !== 'undefined' && type && Notify[type]) {
                    Notify[type](title || '', message || '');
                }
            });
        });
    </script>

    <!-- Automatic Language Detection -->
    <script>
        (function() {
            // Check if user already has a language preference (cookie or session flag)
            function getCookie(name) {
                const value = `; ${document.cookie}`;
                const parts = value.split(`; ${name}=`);
                if (parts.length === 2) return parts.pop().split(';').shift();
                return null;
            }

            const hasPreference = getCookie('django_language');
            const autoLangSet = sessionStorage.getItem('erplora_lang_auto_set');

            // Skip if already has preference OR we've already tried to set it this session
            if (hasPreference || autoLangSet) {
                return;
            }

            // Detect browser language
            const browserLang = navigator.language || navigator.userLanguage;
            const langCode = browserLang.toLowerCase().split('-')[0]; // Get 'es' from 'es-ES'

            // Supported languages
            const supportedLangs = ['en', 'es'];
            const selectedLang = supportedLangs.includes(langCode) ? langCode : 'en';

            // Mark that we've attempted auto-detection (prevent infinite loops)
            sessionStorage.setItem('erplora_lang_auto_set', 'true');

            // Set language preference automatically (only if not English, which is default)
            if (selectedLang !== 'en') {
                // Navigate directly instead of fetch + reload (avoids redirect issues)
                window.location.href = '/set-language/?language=' + selectedLang + '&next=' + encodeURIComponent(window.location.pathname);
            }
        })();
    </script>

    {% block extra_css %}{% endblock %}
    {% block extra_head %}{% endblock %}

    <!-- PWA Install Handler -->
    <script>
        // Store the install prompt event
        let deferredPrompt = null;
        let pwaInstalled = false;

        // Check if app is already installed
        if (window.matchMedia('(display-mode: standalone)').matches) {
            pwaInstalled = true;
        }

        // Listen for the beforeinstallprompt event
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent the mini-infobar from appearing
            e.preventDefault();
            // Save the event for later
            deferredPrompt = e;
            // Show install button
            document.dispatchEvent(new CustomEvent('pwa-installable'));
            console.log('[PWA] Install prompt available');
        });

        // Listen for successful installation
        window.addEventListener('appinstalled', () => {
            pwaInstalled = true;
            deferredPrompt = null;
            document.dispatchEvent(new CustomEvent('pwa-installed'));
            console.log('[PWA] App installed successfully');
        });

        // Function to trigger installation
        async function installPWA() {
            if (!deferredPrompt) {
                console.log('[PWA] No install prompt available');
                return false;
            }

            // Show the install prompt
            deferredPrompt.prompt();

            // Wait for user response
            const { outcome } = await deferredPrompt.userChoice;
            console.log('[PWA] User response:', outcome);

            // Clear the prompt
            deferredPrompt = null;

            return outcome === 'accepted';
        }

        // Check if PWA can be installed
        function canInstallPWA() {
            return deferredPrompt !== null && !pwaInstalled;
        }

        // Check if PWA is installed
        function isPWAInstalled() {
            return pwaInstalled || window.matchMedia('(display-mode: standalone)').matches;
        }
    </script>
    <!-- Auto dark mode detection (runs before body renders to prevent flash) -->
    <script>
        (function() {
            const darkModeAuto = {{ HUB_CONFIG.dark_mode_auto|yesno:"true,false" }};
            const darkModeManual = {{ HUB_CONFIG.dark_mode|yesno:"true,false" }};

            let isDark = false;
            if (darkModeAuto) {
                // Use browser/OS preference
                isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            } else {
                // Use manual setting from database
                isDark = darkModeManual;
            }

            // Store for Alpine.js components to access
            window.ERPlora = window.ERPlora || {};
            window.ERPlora.isDark = isDark;
            window.ERPlora.darkModeAuto = darkModeAuto;

            // Apply immediately to prevent flash
            if (isDark) {
                document.documentElement.classList.add('dark');
            }
        })();
    </script>
</head>
<body>
    <script>
        // Apply dark class to body (documentElement already has it if needed)
        if (window.ERPlora && window.ERPlora.isDark) {
            document.body.classList.add('dark');
        }

        // Listen for system preference changes (only if auto mode)
        if (window.ERPlora && window.ERPlora.darkModeAuto) {
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                document.body.classList.toggle('dark', e.matches);
                document.documentElement.classList.toggle('dark', e.matches);
                window.ERPlora.isDark = e.matches;
            });
        }
    </script>

    <ion-app mode="ios">
        {% block content %}{% endblock %}
    </ion-app>

    <!-- Toast container for HTMX OOB swap -->
    <div id="toast-container"></div>

    {% block scripts %}{% endblock %}
</body>
</html>
